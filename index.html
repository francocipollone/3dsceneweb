<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <link rel="stylesheet" href="css/main.css">
</head>
<body>
  <h1> Scene3D  </h1>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/102/three.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/2.1.2/TweenMax.min.js"></script>
  <!-- <script src="https://cdn.jsdelivr.net/npm/three-orbitcontrols@2.110.3/OrbitControls.min.js"></script> -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.125.1/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.125.1/examples/js/controls/OrbitControls.js"></script>
    <script>
      // import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.121.1/examples/jsm/controls/OrbitControls.js';

      var scene = new THREE.Scene();

      // Add light to the scene
      var light = new THREE.PointLight(0xFFFFFF, 1, 1000)
      light.position.set(100,0,100);
      scene.add(light);

      // Add ligther light  to the scene
      var light = new THREE.PointLight(0xFFFFFF, 2, 1000)
      light.position.set(0,0,100);
      scene.add(light);

      // There are many cameras that can be used
      var camera = new THREE.PerspectiveCamera(
        75, // field of view
        window.innerWidth/window.innerHeight, // aspect_ratio
        0.1, //near plane
        1000 //far plane
      );

      camera.position.y = 4;
      camera.position.z = 10;
      camera.rotation.x =-0.5;

      // Set the renderer. There are different renders. WebGL renderer is one of the three that are supported. This is the most complete one.
      var renderer = new THREE.WebGLRenderer({antialias: true});
      renderer.setClearColor("#e5e5e5") // hex code color: grey
      renderer.setSize(window.innerWidth, window.innerHeight);



      // Append the renderer dom into the document.
      // Is like saying: I've created our canvas(dynamic element in html) element with our rendering settings.
      document.body.appendChild(renderer.domElement);

      // I hook to the window event.
      window.addEventListener('resize', () => {
          renderer.setSize(window.innerWidth, window.innerHeight);
          camera.aspect = window.innerWidth/window.innerHeight;

          // every time there is an adjustment in camera i should call this update.
          camera.updateProjectionMatrix();
      });



      // Creates grid.
      const size = 200;
      const divisions = 200;

      let gridHelper = new THREE.GridHelper( size, divisions );
      gridHelper.position.x = 0;
      gridHelper.position.y = -75;
      gridHelper.position.z = 0;
      // gridHelper.geometry.rotateX(Math.PI / 2);
      scene.add( gridHelper );

      // Call MapControls which by default executes the OrbitControl
      const controls = new THREE.MapControls(camera, renderer.domElement);


      // used to determine where the scene is clicked.
      var raycaster = new THREE.Raycaster();
      var mouse = new THREE.Vector2();

      // every time you create a 3d element in threejs you define:
      // - material
      // - shape
      var geometry = new THREE.BoxGeometry(1, 1, 1);
      // var geometry = new THREE.SphereGeometry(1, 4, 4);
      var material = new THREE.MeshLambertMaterial({color: 0xFFCC00});

      
      meshX = -10;
      for (var i = 0; i < 10000; i++) {
        var geometry = new THREE.BoxGeometry(1, 1, 1);
        var material = new THREE.MeshLambertMaterial({color: 0xFFCC00});
        var mesh = new THREE.Mesh(geometry, material);
        mesh.position.x = (Math.random() - 0.5) * 150;
        mesh.position.y = (Math.random() - 0.5) * 150;
        mesh.position.z = (Math.random() - 0.5) * 150;
        scene.add(mesh);
        meshX+=1;
      }


      // When resizing the window it could distortion the element in the scene.
      // To avoid this, this call this function, which in fact
      // it just loops rendering the scene again and again (60 hs, every time screen refresh).
      // (Why not doing this by hooking to an event.)
      var render = function() {
        requestAnimationFrame(render);
        
        
        // In here we can add our "animations". However in general you use another library for this.
        // mesh.rotation.x += 0.01;
        // mesh.rotation.y += 0.01;
        // mesh.rotation.z += 0.01;
        // mesh.scale.y -= 0.01;
        
        
        
        renderer.render(scene, camera);
      }

      render();

     
      // document.body.addEventListener('click', () => {
      //   this.t1.play();
      // })
      // NOT SURE WHAT'S THE DIFFERENCE BETWEEN window AND document.body.

      function onMouseMove(event) {
        event.preventDefault();
        mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
        mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);
        var intersects = raycaster.intersectObjects(scene.children, true);
        for (var i = 0 ; i < intersects.length; i++) {
          if( intersects[i].object == gridHelper) {
            continue;
          }
          intersects[i].object.material.color.set(0xff0000); // intersects[i] will have the mesh in esence

          // from gsap / TweenMax library: See script include.
          // we can use gsap to animations instead of using just the render loop.
          // For example. We can use TImelineMax to add animations to our object very easily.
          // this.t1 = new TimelineMax().delay(.3); // We can delay it just a bit
          // this.t1 = new TimelineMax({paused: true}); // we can start this pause and then play it
          this.t1 = new TimelineMax();
          this.t1.to(intersects[i].object.scale, 1, {x: 2, ease: Expo.easeOut});
          this.t1.to(intersects[i].object.scale, .5, {x: .5, ease: Expo.easeOut});
          this.t1.to(intersects[i].object.position, .5, {x: 1, ease: Expo.easeOut});
          this.t1.to(intersects[i].object.rotation, .5, {y: Math.PI*.5, ease: Expo.easeOut}, "=-1.5" /* here I say that it should happen 1.5sec before it normally would*/);

        }
      }
      window.addEventListener('mousemove', onMouseMove);
  </script>
</body>
</html>